# GO-Mem-Management

##1. 存储基础知识
存储金字塔：

![](https://segmentfault.com/img/remote/1460000020338431)

从上往下依次是：
* CPU寄存器
* Cache
* 内存
* 硬盘等辅助存储设备
* 鼠标等外接设备

存储体系的分层设计：自顶向下，访问速率越来越低，访问时间越来越长，从磁盘到CPU寄存器，上一层可以看做是下一层的缓存。

##2. 虚拟内存
虚拟内存分层设计：

![](https://segmentfault.com/img/remote/1460000020338434)

上图展示了进程访问数据，当Cache没有命中的时候，访问虚拟内存获取数据的过程。

访问内存，实际访问的是虚拟内存，虚拟内存通过页表查看，当前要访问的虚拟内存地址，是否已经加在到物理内存，
如果已经在物理内存，则取物理内存数据，如果没有对应的物理内存，则从磁盘加载数据到物理内存，并把物理内存地址和
虚拟内存地址更新到页表。

在没有虚拟内存的时代，物理内存对所有进程是共享的，多进程同时访问同一个物理内存存在并发访问问题。引入虚拟内存后，
每个进程都要各自的虚拟内存，内存的并发访问问题的粒度从多进程级别，可以降低到多线程级别。&oq=在没有虚拟内存的时代，
物理内存对所有进程是共享的，多进程同时访问同一个物理内存存在并发访问问题。引入虚拟内存后，每个进程都要各自的虚拟内存，
内存的并发访问问题的粒度从多进程级别，可以降低到多线程级别。

##3. 栈和堆
从虚拟内存，再进一层，看虚拟内存的栈和堆，也就是进程对内存的管理。

![](https://segmentfault.com/img/remote/1460000020338435)

上图展示了一个进程的内存划分，代码中使用的内存地址都是虚拟内存地址，而不是实际的物理内存地址。
栈和堆只是虚拟内存上2块不同功能的内存区域。
* 栈再高地址，从高地址向低地址增长。
* 堆在低地址，从低地址想高地址增长。

**栈和堆相比有这么几个好处：**
1. 栈的内存管理简单，分配比堆上的快。
2. 栈的内存不需要回收，而堆需要。无论是主动free，还是被动的垃圾回收，这都需要花费额外的CPU。
3. 栈上的内存有更好的局部性，堆上内存访问就不那么友好了，CPU访问的2块数据可能在不同的页上，CPU访问
数据的时间可能就上去了。、

##4 堆内存管理
![](https://segmentfault.com/img/remote/1460000020338436)

当我们说内存管理的时候，主要是指堆内存的管理，因为栈的内存管理不需要程序去操心。这小节看下堆内存管理干的是啥，如上图所示主要是3部分：
**分配内存块，回收内存块和组织内存块**。

在一个最简单的内存管理中，堆内存最初会是一个完整的大块，即未分配内存，当来申请的时候，就会从未分配内存，分割出一个小内存块(block)，然后用
链表将所有内存块连接起来。需要一些信息描述每个内存块的基本信息，比如大小(size)，是否使用中(used)和下一个内存块的地址(next)，内存块实际数据存储在data中。

![](https://segmentfault.com/img/remote/1460000020338437)

释放内存实质是把使用的内存块从链表中取出来，然后标记为未使用，当分配内存块的时候，可以从未使用内存块中有先查找大小相近的内存块，如果找不到，
再从未分配的内存中分配内存。

上面这个简单的设计中还没考虑内存碎片的问题，因为随着内存不断的申请和释放，内存上会存在大量的碎片，降低内存的使用率。为了解决内存碎片，
可以将2个连续的未使用的内存块合并，减少碎片。

以上就是内存管理的基本思路，关于基本的内存管理，想了解更多，可以阅读这篇文章《Writing+a+Memory+Allocator》，本节的3张图片也是来自这片文章。

